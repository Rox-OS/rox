module titan;

type LimineFramebuffer = (
  address:    *Uint32,
  dimensions: (Uint64, Uint64),
  pitch:      Uint64,
  bpp:        Uint16,
  mem_model:  Uint8,
  r_mask:     (size: Uint8, shift: Uint8),
  g_mask:     (size: Uint8, shift: Uint8),
  b_mask:     (size: Uint8, shift: Uint8),
              Uint8,
  edid:       (size: Uint64, data: Address),
  modes:      (Uint64, Address)
);

type LimineFramebufferRequest = (
  id:       [4]Uint64,
  revision: Uint64,
  response: *LimineFramebufferResponse
);

type LimineFramebufferResponse = (
  revision:     Uint64,
  framebuffers: (Uint64, **LimineFramebuffer)
);

type LimineHHDMRequest = (
  id:       [4]Uint64,
  revision: Uint64,
  response: *LimineHHDMResponse
);

type LimineHHDMResponse = (
  revision: Uint64,
  offset:   Uint64
);

type LimineStackSizeRequest = (
  id:       [4]Uint64,
  revision: Uint64,
  response: *LimineStackSizeResponse,
  size:     Uint64
);

type LimineStackSizeResponse = (
  revision: Uint64
);

@(used(true), section(".requests"))
let LIMINE_BASE_VERSION = [3]Uint64 {
  0xf9562b2d5c95a6c8_u64,
  0x6a7b384944536bdc_u64,
  2_u64
};

@(used(true), section(".requests_beg_marker"))
let LIMINE_REQUESTS_BEG_MARKER = [4]Uint64 {
  0xf6b8f4b39de7d1ae_u64,
  0xfab91a6940fcb9cf_u64,
  0x785c6ed015d3e316_u64,
  0x181e920a7852b9d9_u64
};

@(used(true), section(".requests"))
let LIMINE_HHDM_REQUEST = LimineHHDMRequest {
  [4]Uint64 {
    0xc7b1dd30df4c8b88_u64,
    0x0a82e883a194f07b_u64,
    0x48dcf1cb8ad2b852_u64,
    0x63984e959a98244b_u64,
  },
  0_u64
};

@(used(true), section(".requests"))
let LIMINE_STACK_SIZE_REQUEST = LimineStackSizeRequest {
  [4]Uint64 {
    0xc7b1dd30df4c8b88_u64,
    0x0a82e883a194f07b_u64,
    0x224ef0460a8e8926_u64,
    0xe1cb0fc25f46ea3d_u64,
  },
  0_u64,
  0_u64,
  128_u64 * 1024_u64 * 1024_u64, // 128 MiB
};

@(used(true), section(".requests"))
let LIMINE_FRAMEBUFFER_REQUEST = LimineFramebufferRequest {
  [4]Uint64 {
    0xc7b1dd30df4c8b88_u64,
    0x0a82e883a194f07b_u64,
    0x9d5827dcd881dd75_u64,
    0xa3148604f6fab11b_u64
  },
  1_u64
};

@(used(true), section(".requests_end_marker"))
let LIMINE_REQUESTS_END_MARKER = [2]Uint64 {
  0xadc0e0531bb10d03_u64,
  0x9572709f31764c62_u64
};

// An 8x8 Latin font
let FONT = [128][8]Uint8 {
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x18_u8, 0x3C_u8, 0x3C_u8, 0x18_u8, 0x18_u8, 0x00_u8, 0x18_u8, 0x00_u8 },
  [8]Uint8 { 0x36_u8, 0x36_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x36_u8, 0x36_u8, 0x7F_u8, 0x36_u8, 0x7F_u8, 0x36_u8, 0x36_u8, 0x00_u8 },
  [8]Uint8 { 0x0C_u8, 0x3E_u8, 0x03_u8, 0x1E_u8, 0x30_u8, 0x1F_u8, 0x0C_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x63_u8, 0x33_u8, 0x18_u8, 0x0C_u8, 0x66_u8, 0x63_u8, 0x00_u8 },
  [8]Uint8 { 0x1C_u8, 0x36_u8, 0x1C_u8, 0x6E_u8, 0x3B_u8, 0x33_u8, 0x6E_u8, 0x00_u8 },
  [8]Uint8 { 0x06_u8, 0x06_u8, 0x03_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x18_u8, 0x0C_u8, 0x06_u8, 0x06_u8, 0x06_u8, 0x0C_u8, 0x18_u8, 0x00_u8 },
  [8]Uint8 { 0x06_u8, 0x0C_u8, 0x18_u8, 0x18_u8, 0x18_u8, 0x0C_u8, 0x06_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x66_u8, 0x3C_u8, 0xFF_u8, 0x3C_u8, 0x66_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x0C_u8, 0x0C_u8, 0x3F_u8, 0x0C_u8, 0x0C_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x0C_u8, 0x0C_u8, 0x06_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x3F_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x0C_u8, 0x0C_u8, 0x00_u8 },
  [8]Uint8 { 0x60_u8, 0x30_u8, 0x18_u8, 0x0C_u8, 0x06_u8, 0x03_u8, 0x01_u8, 0x00_u8 },
  [8]Uint8 { 0x3E_u8, 0x63_u8, 0x73_u8, 0x7B_u8, 0x6F_u8, 0x67_u8, 0x3E_u8, 0x00_u8 },
  [8]Uint8 { 0x0C_u8, 0x0E_u8, 0x0C_u8, 0x0C_u8, 0x0C_u8, 0x0C_u8, 0x3F_u8, 0x00_u8 },
  [8]Uint8 { 0x1E_u8, 0x33_u8, 0x30_u8, 0x1C_u8, 0x06_u8, 0x33_u8, 0x3F_u8, 0x00_u8 },
  [8]Uint8 { 0x1E_u8, 0x33_u8, 0x30_u8, 0x1C_u8, 0x30_u8, 0x33_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x38_u8, 0x3C_u8, 0x36_u8, 0x33_u8, 0x7F_u8, 0x30_u8, 0x78_u8, 0x00_u8 },
  [8]Uint8 { 0x3F_u8, 0x03_u8, 0x1F_u8, 0x30_u8, 0x30_u8, 0x33_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x1C_u8, 0x06_u8, 0x03_u8, 0x1F_u8, 0x33_u8, 0x33_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x3F_u8, 0x33_u8, 0x30_u8, 0x18_u8, 0x0C_u8, 0x0C_u8, 0x0C_u8, 0x00_u8 },
  [8]Uint8 { 0x1E_u8, 0x33_u8, 0x33_u8, 0x1E_u8, 0x33_u8, 0x33_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x1E_u8, 0x33_u8, 0x33_u8, 0x3E_u8, 0x30_u8, 0x18_u8, 0x0E_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x0C_u8, 0x0C_u8, 0x00_u8, 0x00_u8, 0x0C_u8, 0x0C_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x0C_u8, 0x0C_u8, 0x00_u8, 0x00_u8, 0x0C_u8, 0x0C_u8, 0x06_u8 },
  [8]Uint8 { 0x18_u8, 0x0C_u8, 0x06_u8, 0x03_u8, 0x06_u8, 0x0C_u8, 0x18_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x3F_u8, 0x00_u8, 0x00_u8, 0x3F_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x06_u8, 0x0C_u8, 0x18_u8, 0x30_u8, 0x18_u8, 0x0C_u8, 0x06_u8, 0x00_u8 },
  [8]Uint8 { 0x1E_u8, 0x33_u8, 0x30_u8, 0x18_u8, 0x0C_u8, 0x00_u8, 0x0C_u8, 0x00_u8 },
  [8]Uint8 { 0x3E_u8, 0x63_u8, 0x7B_u8, 0x7B_u8, 0x7B_u8, 0x03_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x0C_u8, 0x1E_u8, 0x33_u8, 0x33_u8, 0x3F_u8, 0x33_u8, 0x33_u8, 0x00_u8 },
  [8]Uint8 { 0x3F_u8, 0x66_u8, 0x66_u8, 0x3E_u8, 0x66_u8, 0x66_u8, 0x3F_u8, 0x00_u8 },
  [8]Uint8 { 0x3C_u8, 0x66_u8, 0x03_u8, 0x03_u8, 0x03_u8, 0x66_u8, 0x3C_u8, 0x00_u8 },
  [8]Uint8 { 0x1F_u8, 0x36_u8, 0x66_u8, 0x66_u8, 0x66_u8, 0x36_u8, 0x1F_u8, 0x00_u8 },
  [8]Uint8 { 0x7F_u8, 0x46_u8, 0x16_u8, 0x1E_u8, 0x16_u8, 0x46_u8, 0x7F_u8, 0x00_u8 },
  [8]Uint8 { 0x7F_u8, 0x46_u8, 0x16_u8, 0x1E_u8, 0x16_u8, 0x06_u8, 0x0F_u8, 0x00_u8 },
  [8]Uint8 { 0x3C_u8, 0x66_u8, 0x03_u8, 0x03_u8, 0x73_u8, 0x66_u8, 0x7C_u8, 0x00_u8 },
  [8]Uint8 { 0x33_u8, 0x33_u8, 0x33_u8, 0x3F_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x00_u8 },
  [8]Uint8 { 0x1E_u8, 0x0C_u8, 0x0C_u8, 0x0C_u8, 0x0C_u8, 0x0C_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x78_u8, 0x30_u8, 0x30_u8, 0x30_u8, 0x33_u8, 0x33_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x67_u8, 0x66_u8, 0x36_u8, 0x1E_u8, 0x36_u8, 0x66_u8, 0x67_u8, 0x00_u8 },
  [8]Uint8 { 0x0F_u8, 0x06_u8, 0x06_u8, 0x06_u8, 0x46_u8, 0x66_u8, 0x7F_u8, 0x00_u8 },
  [8]Uint8 { 0x63_u8, 0x77_u8, 0x7F_u8, 0x7F_u8, 0x6B_u8, 0x63_u8, 0x63_u8, 0x00_u8 },
  [8]Uint8 { 0x63_u8, 0x67_u8, 0x6F_u8, 0x7B_u8, 0x73_u8, 0x63_u8, 0x63_u8, 0x00_u8 },
  [8]Uint8 { 0x1C_u8, 0x36_u8, 0x63_u8, 0x63_u8, 0x63_u8, 0x36_u8, 0x1C_u8, 0x00_u8 },
  [8]Uint8 { 0x3F_u8, 0x66_u8, 0x66_u8, 0x3E_u8, 0x06_u8, 0x06_u8, 0x0F_u8, 0x00_u8 },
  [8]Uint8 { 0x1E_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x3B_u8, 0x1E_u8, 0x38_u8, 0x00_u8 },
  [8]Uint8 { 0x3F_u8, 0x66_u8, 0x66_u8, 0x3E_u8, 0x36_u8, 0x66_u8, 0x67_u8, 0x00_u8 },
  [8]Uint8 { 0x1E_u8, 0x33_u8, 0x07_u8, 0x0E_u8, 0x38_u8, 0x33_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x3F_u8, 0x2D_u8, 0x0C_u8, 0x0C_u8, 0x0C_u8, 0x0C_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x33_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x3F_u8, 0x00_u8 },
  [8]Uint8 { 0x33_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x1E_u8, 0x0C_u8, 0x00_u8 },
  [8]Uint8 { 0x63_u8, 0x63_u8, 0x63_u8, 0x6B_u8, 0x7F_u8, 0x77_u8, 0x63_u8, 0x00_u8 },
  [8]Uint8 { 0x63_u8, 0x63_u8, 0x36_u8, 0x1C_u8, 0x1C_u8, 0x36_u8, 0x63_u8, 0x00_u8 },
  [8]Uint8 { 0x33_u8, 0x33_u8, 0x33_u8, 0x1E_u8, 0x0C_u8, 0x0C_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x7F_u8, 0x63_u8, 0x31_u8, 0x18_u8, 0x4C_u8, 0x66_u8, 0x7F_u8, 0x00_u8 },
  [8]Uint8 { 0x1E_u8, 0x06_u8, 0x06_u8, 0x06_u8, 0x06_u8, 0x06_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x03_u8, 0x06_u8, 0x0C_u8, 0x18_u8, 0x30_u8, 0x60_u8, 0x40_u8, 0x00_u8 },
  [8]Uint8 { 0x1E_u8, 0x18_u8, 0x18_u8, 0x18_u8, 0x18_u8, 0x18_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x08_u8, 0x1C_u8, 0x36_u8, 0x63_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0xFF_u8 },
  [8]Uint8 { 0x0C_u8, 0x0C_u8, 0x18_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x1E_u8, 0x30_u8, 0x3E_u8, 0x33_u8, 0x6E_u8, 0x00_u8 },
  [8]Uint8 { 0x07_u8, 0x06_u8, 0x06_u8, 0x3E_u8, 0x66_u8, 0x66_u8, 0x3B_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x1E_u8, 0x33_u8, 0x03_u8, 0x33_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x38_u8, 0x30_u8, 0x30_u8, 0x3e_u8, 0x33_u8, 0x33_u8, 0x6E_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x1E_u8, 0x33_u8, 0x3f_u8, 0x03_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x1C_u8, 0x36_u8, 0x06_u8, 0x0f_u8, 0x06_u8, 0x06_u8, 0x0F_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x6E_u8, 0x33_u8, 0x33_u8, 0x3E_u8, 0x30_u8, 0x1F_u8 },
  [8]Uint8 { 0x07_u8, 0x06_u8, 0x36_u8, 0x6E_u8, 0x66_u8, 0x66_u8, 0x67_u8, 0x00_u8 },
  [8]Uint8 { 0x0C_u8, 0x00_u8, 0x0E_u8, 0x0C_u8, 0x0C_u8, 0x0C_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x30_u8, 0x00_u8, 0x30_u8, 0x30_u8, 0x30_u8, 0x33_u8, 0x33_u8, 0x1E_u8 },
  [8]Uint8 { 0x07_u8, 0x06_u8, 0x66_u8, 0x36_u8, 0x1E_u8, 0x36_u8, 0x67_u8, 0x00_u8 },
  [8]Uint8 { 0x0E_u8, 0x0C_u8, 0x0C_u8, 0x0C_u8, 0x0C_u8, 0x0C_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x33_u8, 0x7F_u8, 0x7F_u8, 0x6B_u8, 0x63_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x1F_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x1E_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x1E_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x3B_u8, 0x66_u8, 0x66_u8, 0x3E_u8, 0x06_u8, 0x0F_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x6E_u8, 0x33_u8, 0x33_u8, 0x3E_u8, 0x30_u8, 0x78_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x3B_u8, 0x6E_u8, 0x66_u8, 0x06_u8, 0x0F_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x3E_u8, 0x03_u8, 0x1E_u8, 0x30_u8, 0x1F_u8, 0x00_u8 },
  [8]Uint8 { 0x08_u8, 0x0C_u8, 0x3E_u8, 0x0C_u8, 0x0C_u8, 0x2C_u8, 0x18_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x6E_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x1E_u8, 0x0C_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x63_u8, 0x6B_u8, 0x7F_u8, 0x7F_u8, 0x36_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x63_u8, 0x36_u8, 0x1C_u8, 0x36_u8, 0x63_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x33_u8, 0x33_u8, 0x33_u8, 0x3E_u8, 0x30_u8, 0x1F_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x3F_u8, 0x19_u8, 0x0C_u8, 0x26_u8, 0x3F_u8, 0x00_u8 },
  [8]Uint8 { 0x38_u8, 0x0C_u8, 0x0C_u8, 0x07_u8, 0x0C_u8, 0x0C_u8, 0x38_u8, 0x00_u8 },
  [8]Uint8 { 0x18_u8, 0x18_u8, 0x18_u8, 0x00_u8, 0x18_u8, 0x18_u8, 0x18_u8, 0x00_u8 },
  [8]Uint8 { 0x07_u8, 0x0C_u8, 0x0C_u8, 0x38_u8, 0x0C_u8, 0x0C_u8, 0x07_u8, 0x00_u8 },
  [8]Uint8 { 0x6E_u8, 0x3B_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 },
  [8]Uint8 { 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8, 0x00_u8 } 
};

@(export(true))
fn memset(dst: *Uint8, value: Uint32, num: Uint64) {
  let ch  = (value & 0xff_u32) as Uint8;
  for let i = 0_u64; i < num; i += 1_u64 {
    dst[i] = ch;
  }
}

fn make_color(fb: *LimineFramebuffer, r: Uint32, g: Uint32, b: Uint32) -> Uint32 {
  return (r << fb.r_mask.shift as Uint32) |
         (g << fb.g_mask.shift as Uint32) |
         (b << fb.b_mask.shift as Uint32);
}

// When in the kernel we do not want the Redzone and we want Biron to always
// setup the stack so it's 16-byte aligned. This behavior is required by SysV
// and will be true of all other functions but not necessarily the entry point.
// We also need to export the kmain so the bootloader can actually call us. This
// entry point is set in link.ld.
@(export(true), redzone(false), alignstack(16))
fn kmain() {
  enable_fpu();

  // Ensure we support 128 MiB stack, Higher-Half Direct Map and a XRGB Framebuffer
  if LIMINE_STACK_SIZE_REQUEST.response == 0_u64 as *LimineStackSizeResponse {
    for {}
  }
  if LIMINE_HHDM_REQUEST.response == 0_u64 as *LimineHHDMResponse {
    for {}
  }
  if LIMINE_FRAMEBUFFER_REQUEST.response == 0_u64 as *LimineFramebufferResponse {
    for {}
  }

  let fb = LIMINE_FRAMEBUFFER_REQUEST.response.framebuffers.1[0];

  let sim = &Sim{};
  sim.init();
  // Then ~~burn~~ sim forever.
  for {
    sim.step();
    clear(fb);
    hello(fb);
    sim.render(fb);
  }
}

fn clear(fb: *LimineFramebuffer) {
  // Clear the framebuffer to a nice shade of grey.
  for let y = 0_u64; y < fb.dimensions.1; y = y + 1_u64 {
    for let x = 0_u64; x < fb.dimensions.0; x = x + 1_u64 {
      fb.address[y * fb.dimensions.0 + x] = make_color(fb, 0x20_u32, 0x20_u32, 0x20_u32);
    }
  }
}

fn hello(fb: *LimineFramebuffer) {
  // Then print "Hello RoxOS!" in the center of the screen in yellow.
  let msg = [12]Uint8 { 'H', 'e', 'l', 'l', 'o', ' ', 'R', 'o', 'x', 'O', 'S', '!' };
  let PX = (fb.dimensions.0 >> 1_u64) - (12_u64 >> 1_u64) * 8_u64;
  let PY = (fb.dimensions.1 >> 1_u64) - (8_u64  >> 1_u64) * 8_u64;
  let px = PX;
  let py = PY;
  for let y = 0_u32; y < 8_u32; y = y + 1_u32 {
    for let i = 0_u32; i < 12_u32; i = i + 1_u32 {
      let bits = FONT[msg[i]][y] as Uint32;
      for let x = 0_u32; x < 8_u32; x = x + 1_u32 {
        let set = bits & (1_u32 << x);
        if set != 0_u32 {
          let dst = &fb.address[py * fb.dimensions.0];
          dst[px] = make_color(fb, 0xff_u32, 0xff_u32, 0x00_u32);
        } else {
          // printf(" ");
        }
        px = px + 1_u64;
      }
    }
    py = py + 1_u64;
    px = PX;
  }
}

type Sim = (
  particles: [48_u64 * 48_u64]Particle,
  boundary_particles: [2 * 128 + 2 * 128 + 2 * 2][2]Real32,
  world_size: [2]Real32
);

type Particle = (
  initial_position: [2]Real32,
  position: [2]Real32,
  velocity: [2]Real32,
  density:  Real32
);

let H = 2.0_f32;
let REST_DENSITY = 1.0_f32;
let GRAVITY = 0.05_f32;
let STIFFNESS = 1.75_f32;
let RESTITUTION = 0.05_f32;

fn sph_kernel(r: Real32) -> Real32 {
  let result = 0.45472841_f32; // 40 / (7 * pi * h^2)
  let q = r / H;
  if q <= 0.5_f32 {
    result = result * (6_f32 * (q*q*q - q*q) + 1_f32);
  } else {
    let a = 1.0_f32 - q;
    result = result * 2.0_f32 * a*a*a;
  }
  return result;
}

fn particle_pressure(p: *Particle) -> Real32 {
  let pressure = STIFFNESS * (p.density - REST_DENSITY);
  if pressure < 0_f32 {
    pressure = 0_f32;
  }
  return pressure;
}


fn (sim: *Sim) init() {
  let world_size = [2]Real32{128_f32, 128_f32};
  sim.world_size = world_size;

  // TODO(said): Hard-coded for now
  let n_particles_x = 48_u64;
  let n_particles_y = 48_u64;
  let n_particles = n_particles_x * n_particles_y;
  let n_boundary_particles = 2_u64 * (128_u64 + 128_u64 + 2_u64);

  let particles = &sim.particles[0];
  let boundary_particles = &sim.boundary_particles[0];

  for let i = 0_s64; i < 128_s64 + 2_s64; i += 1_s64 {
    boundary_particles[i]                   = [2]Real32{(i as Real32) - 0.5_f32, -0.5_f32};
    boundary_particles[i + 128_s64 + 2_s64] = [2]Real32{(i as Real32) - 0.5_f32, world_size[1] + 0.5_f32};
  }
  for let i = 0_s64; i < 128_s64; i += 1_s64 {
    boundary_particles[i + 2_s64 * (128_s64 + 2_s64)]           = [2]Real32{-0.5_f32,                (i as Real32) + 0.5_f32};
    boundary_particles[i + 2_s64 * (128_s64 + 2_s64) + 128_s64] = [2]Real32{world_size[0] + 0.5_f32, (i as Real32) + 0.5_f32};
  }

  let block_x = 0.5_f32;
  let block_y = 0.75_f32 * world_size[1] - 0.5_f32;

  for let y = 0_u64; y < n_particles_y; y = y + 1_u64 {
    for let x = 0_u64; x < n_particles_x; x = x + 1_u64 {
      let particle = &particles[y * n_particles_x + x];
      particle.position[0] = block_x + (x as Real32);
      particle.position[1] = block_y - (y as Real32);
    }
  }
}

fn (sim: *Sim) step() {
  // TODO(said): Hard-coded for now
  let n_particles = 48_u64 * 48_u64;
  let n_boundary_particles = 2_u64 * (128_u64 + 128_u64 + 2_u64);

  let particles = &sim.particles[0];
  let boundary_particles = &sim.boundary_particles[0];

  // Apply forces and "advect" the particles.
  for let i = 0_u64; i < n_particles; i += 1_u64 {
    let particle = &particles[i];

    particle.initial_position = particle.position;

    particle.velocity[1] += GRAVITY;

    particle.position[0] += particle.velocity[0];
    particle.position[1] += particle.velocity[1];
  }

  // Estimate density.
  for let i = 0_u64; i < n_particles; i += 1_u64 {
    let particle = &particles[i];
    particle.density = 0_f32;

    // Count fluid particles.
    for let j = 0_u64; j < n_particles; j += 1_u64 {
      let neighbor = &particles[j];
      let delta = [2]Real32{
        particle.position[0] - neighbor.position[0],
        particle.position[1] - neighbor.position[1]
      };
      let r = sqrt(delta[0] * delta[0] + delta[1] * delta[1]);
      if r < H {
        particle.density += sph_kernel(r);
      }
    }

    // Count boundary particles.
    for let j = 0_u64; j < n_boundary_particles; j += 1_u64 {
      let delta = [2]Real32{
        particle.position[0] - boundary_particles[j][0],
        particle.position[1] - boundary_particles[j][1]
      };
      let r = sqrt(delta[0] * delta[0] + delta[1] * delta[1]);
      if r < H {
        particle.density += sph_kernel(r);
      }
    }
  }

  // Compute pressure.
  for let i = 0_u64; i < n_particles; i += 1_u64 {
    let particle = &particles[i];

    let f_p = particle_pressure(particle) / (particle.density * particle.density);
    let force = [2]Real32{};

    for let j = 0_u64; j < n_particles; j += 1_u64 {
      if i != j {
        let neighbor = &particles[j];
        let d = [2]Real32{
          particle.position[0] - neighbor.position[0],
          particle.position[1] - neighbor.position[1]
        };
        let r = sqrt(d[0]*d[0] + d[1]*d[1]);
        if r < H {
          if r <= 0.01_f32 {
            if j < i {
              d[0] = 1_f32;
            } else {
              d[0] = -1_f32;
            }
            d[1] = 0_f32;
            r = 1_f32;
          } else {
            d[0] = d[0] / r;
            d[1] = d[1] / r;
          }
          let w = H - r;
          w *= 0.23873241_f32; // 12 / (pi * h^4)
          let f_n = particle_pressure(neighbor) / (neighbor.density * neighbor.density);
          let f = (f_p + f_n) * w;
          force[0] += f * d[0];
          force[1] += f * d[1];
        }
      }
    }

    for let j = 0_u64; j < n_boundary_particles; j = j + 1_u64 {
      let d = [2]Real32{
        particle.position[0] - boundary_particles[j][0],
        particle.position[1] - boundary_particles[j][1]
      };
      let r = sqrt(d[0]*d[0] + d[1]*d[1]);
      if r < H {
        let w = H - r;
        w *= 0.23873241_f32; // 12 / (pi * h^4)
        let f_n = particle_pressure(particle) / (REST_DENSITY * REST_DENSITY);
        let f = (f_p + f_n) * w;
        force[0] += f * d[0];
        force[1] += f * d[1];
      }
    }

    particle.velocity[0] += force[0] / particle.density;
    particle.velocity[1] += force[1] / particle.density;
  }

  // Use pressure-corrected velocity and apply boundary conditions.
  for let i = 0_u64; i < n_particles; i += 1_u64 {
    let particle = &particles[i];
    particle.position[0] = particle.initial_position[0] + particle.velocity[0];
    particle.position[1] = particle.initial_position[1] + particle.velocity[1];

    for let c = 0_u64; c < 2_u64; c += 1_u64 {
      if particle.position[c] < 0.5_f32 {
        particle.position[c] = 0.5_f32;
        if particle.velocity[c] < 0_f32 {
          particle.velocity[c] *= -RESTITUTION;
        }
      } else if particle.position[c] > sim.world_size[c] - 0.5_f32 {
        particle.position[c] = sim.world_size[c] - 0.5_f32;
        if particle.velocity[c] > 0_f32 {
          particle.velocity[c] = particle.velocity[c] * -RESTITUTION;
        }
      }
    }
  }
}

fn (sim: *Sim) render(fb: *LimineFramebuffer) {
  // TODO(said): Hard-coded for now
  let n_particles = 48_u64 * 48_u64;
  let n_boundary_particles = 2_u64 * (128_u64 + 128_u64 + 2_u64);

  let particles = &sim.particles[0];
  let boundary_particles = &sim.boundary_particles[0];

  // Draw the particles.
  for let i = 0_u64; i < n_particles; i += 1_u64 {
    let pressure = particle_pressure(&particles[i]) / STIFFNESS;
    if pressure > 1_f32 {
      pressure = 1_f32;
    }
    let color = (0_u32, 255_u32, ((1.0_f32 - pressure) * 255.0_f32) as Uint32);
    draw_scaled_particle(fb, particles[i].position, make_color(fb, ...color));
  }

  for let i = 0_u64; i < n_boundary_particles; i += 1_u64 {
    let x = (boundary_particles[i][0] + 0.5_f32) as Sint64;
    let y = (boundary_particles[i][1] + 0.5_f32) as Sint64;
    draw_scaled_pixel(fb, x, y, make_color(fb, 0_u32, 0_u32, 0_u32));
  }
}

fn draw_scaled_pixel(fb: *LimineFramebuffer, x: Sint64, y: Sint64, color: Uint32) {
  x *= 4_s64;
  y *= 4_s64;
  x += (fb.dimensions.0 as Sint64 - 4_s64 * 128_s64) / 2_s64;
  y += (fb.dimensions.1 as Sint64 - 4_s64 * 128_s64) / 2_s64;
  for let p = 0_s64; p < 16_s64; p += 1_s64 {
    let py = p & 3_s64;
    let px = p >> 2_s64;
    fb.address[(y + py - 3_s64) * (fb.dimensions.0 as Sint64) + (x + px - 3_s64)] = color;
  }
}

fn draw_scaled_particle(fb: *LimineFramebuffer, p: [2]Real32, color: Uint32) {
  let x = (4.0_f32 * p[0] + 0.5_f32) as Sint64;
  let y = (4.0_f32 * p[1] + 0.5_f32) as Sint64;
  x += (fb.dimensions.0 as Sint64 - 4_s64 * 128_s64) / 2_s64;
  y += (fb.dimensions.1 as Sint64 - 4_s64 * 128_s64) / 2_s64;
  fb.address[y * (fb.dimensions.0 as Sint64) + x] = color;
}