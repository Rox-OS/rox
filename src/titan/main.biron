module titan;

type LimineFramebuffer = (
  address:    *Uint32,
  dimensions: (Uint64, Uint64),
  pitch:      Uint64,
  bpp:        Uint16,
  mem_model:  Uint8,
  r_mask:     (size: Uint8, shift: Uint8),
  g_mask:     (size: Uint8, shift: Uint8),
  b_mask:     (size: Uint8, shift: Uint8),
              Uint8,
  edid:       (size: Uint64, data: Address),
  modes:      (Uint64, Address)
);

type LimineFramebufferRequest = (
  id:       [4]Uint64,
  revision: Uint64,
  response: *LimineFramebufferResponse
);

type LimineFramebufferResponse = (
  revision:     Uint64,
  framebuffers: (Uint64, **LimineFramebuffer)
);

type LimineHHDMRequest = (
  id:       [4]Uint64,
  revision: Uint64,
  response: *LimineHHDMResponse
);

type LimineHHDMResponse = (
  revision: Uint64,
  offset:   Uint64
);

type LimineStackSizeRequest = (
  id:       [4]Uint64,
  revision: Uint64,
  response: *LimineStackSizeResponse,
  size:     Uint64
);

type LimineStackSizeResponse = (
  revision: Uint64
);

@(export(true), section(".requests"))
let LIMINE_BASE_VERSION = new [3]Uint64 {
  0xf9562b2d5c95a6c8,
  0x6a7b384944536bdc,
  2
};

@(export(true), section(".requests_beg_marker"))
let LIMINE_REQUESTS_BEG_MARKER = new [4]Uint64 {
  0xf6b8f4b39de7d1ae,
  0xfab91a6940fcb9cf,
  0x785c6ed015d3e316,
  0x181e920a7852b9d9
};

@(export(true), section(".requests"))
let LIMINE_HHDM_REQUEST = new LimineHHDMRequest {
  {
    0xc7b1dd30df4c8b88,
    0x0a82e883a194f07b,
    0x48dcf1cb8ad2b852,
    0x63984e959a98244b,
  },
  0
};

@(export(true), section(".requests"))
let LIMINE_STACK_SIZE_REQUEST = new LimineStackSizeRequest {
  {
    0xc7b1dd30df4c8b88,
    0x0a82e883a194f07b,
    0x224ef0460a8e8926,
    0xe1cb0fc25f46ea3d,
  },
  0,
  0 as Address,
  128 * 1024 * 1024, // 128 MiB
};

@(export(true), section(".requests"))
let LIMINE_FRAMEBUFFER_REQUEST = new LimineFramebufferRequest {
  {
    0xc7b1dd30df4c8b88,
    0x0a82e883a194f07b,
    0x9d5827dcd881dd75,
    0xa3148604f6fab11b
  },
  1
};

@(export(true), section(".requests_end_marker"))
let LIMINE_REQUESTS_END_MARKER = new [2]Uint64 {
  0xadc0e0531bb10d03,
  0x9572709f31764c62
};

// An 8x8 Latin font
let FONT = new [128][8]Uint8 {
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00 },
  { 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00 },
  { 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00 },
  { 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00 },
  { 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00 },
  { 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00 },
  { 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00 },
  { 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00 },
  { 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06 },
  { 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00 },
  { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00 },
  { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00 },
  { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00 },
  { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00 },
  { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00 },
  { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00 },
  { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00 },
  { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00 },
  { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00 },
  { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00 },
  { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00 },
  { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00 },
  { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06 },
  { 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00 },
  { 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00 },
  { 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00 },
  { 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00 },
  { 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00 },
  { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00 },
  { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00 },
  { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00 },
  { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00 },
  { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00 },
  { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00 },
  { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00 },
  { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00 },
  { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 },
  { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00 },
  { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00 },
  { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00 },
  { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00 },
  { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00 },
  { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00 },
  { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00 },
  { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00 },
  { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00 },
  { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00 },
  { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 },
  { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00 },
  { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00 },
  { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00 },
  { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00 },
  { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00 },
  { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00 },
  { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00 },
  { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00 },
  { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00 },
  { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF },
  { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00 },
  { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00 },
  { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00 },
  { 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00 },
  { 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00 },
  { 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00 },
  { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F },
  { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00 },
  { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 },
  { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E },
  { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00 },
  { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 },
  { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00 },
  { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00 },
  { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00 },
  { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F },
  { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78 },
  { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00 },
  { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00 },
  { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00 },
  { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00 },
  { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00 },
  { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00 },
  { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00 },
  { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F },
  { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00 },
  { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00 },
  { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00 },
  { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00 },
  { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } 
};

@(export(true))
fn memset(dst: *Uint8, value: Uint32, num: Uint64) {
  let ch = (value & 0xff) as Uint8;
  for let i = 0_u64; i < num; i += 1 {
    dst[i] = ch;
  }
}

fn make_color(fb: *LimineFramebuffer, r: Uint32, g: Uint32, b: Uint32) -> Uint32 {
  return (r << fb.r_mask.shift as Uint32) |
         (g << fb.g_mask.shift as Uint32) |
         (b << fb.b_mask.shift as Uint32);
}

@(section(".text"))
let enable_fpu = new [?]Uint8 {
  0x48, 0x83, 0xec, 0x02,             // sub    $0x2,%rsp
  0x0f, 0x20, 0xe0,                   // mov    %cr4,%rax
  0x48, 0x0d, 0x00, 0x02, 0x00, 0x00, // or     $0x200,%rax
  0x0f, 0x22, 0xe0,                   // mov    %rax,%cr4
  0x66, 0xc7, 0x04, 0x24, 0x7f, 0x03, // movw   $0x37f,(%rsp)
  0xd9, 0x2c, 0x24,                   // fldcw  (%rsp)
  0x48, 0x83, 0xc4, 0x02,             // add    $0x2,%rsp
  0xc3                                // ret
};

// When in the kernel we do not want the Redzone and we want Biron to always
// setup the stack so it's 16-byte aligned. This behavior is required by SysV
// and will be true of all other functions but not necessarily the entry point.
// We also need to export the kmain so the bootloader can actually call us. This
// entry point is set in link.ld.
@(export(true), redzone(false), alignstack(16))
fn kmain() {
  (&enable_fpu as fn())();

  // Ensure we support 128 MiB stack, Higher-Half Direct Map and a XRGB Framebuffer
  if LIMINE_STACK_SIZE_REQUEST.response == 0_u64 as *LimineStackSizeResponse {
    for {}
  }
  if LIMINE_HHDM_REQUEST.response == 0_u64 as *LimineHHDMResponse {
    for {}
  }
  if LIMINE_FRAMEBUFFER_REQUEST.response == 0_u64 as *LimineFramebufferResponse {
    for {}
  }

  let fb = LIMINE_FRAMEBUFFER_REQUEST.response.framebuffers.1[0];

  let sim = &new Sim{ };
  sim.init();
  // Then ~~burn~~ sim forever.
  for {
    sim.step();
    clear(fb);
    hello(fb);
    sim.render(fb);
  }
}

fn clear(fb: *LimineFramebuffer) {
  // Clear the framebuffer to a nice shade of grey.
  for let y = 0_u64; y < fb.dimensions.1; y += 1 {
    for let x = 0_u64; x < fb.dimensions.0; x += 1 {
      fb.address[y * fb.dimensions.0 + x] = make_color(fb, 0x20_u32, 0x20_u32, 0x20_u32);
    }
  }
}

fn hello(fb: *LimineFramebuffer) {
  // Then print "Hello RoxOS!" in the center of the screen in yellow.
  let msg = "Hello RoxOS!";
  let PX = (fb.dimensions.0 >> 1) - 12 / 2 * count of FONT[0];
  let PY = (fb.dimensions.1 >> 1) - (count of FONT[0] / 2) * count of FONT[0];
  let px = PX;
  let py = PY;
  for let y = 0_u64; y < count of FONT[0]; y += 1 {
    for let i = 0_u64; i < 12; i += 1 {
      let bits = FONT[msg[i]][y] as Uint64;
      for let x = 0_u64; x < count of FONT[0]; x += 1 {
        let set = bits & (1 << x);
        if set != 0 {
          let dst = &fb.address[py * fb.dimensions.0];
          dst[px] = make_color(fb, 0xff, 0xff, 0x00);
        } else {
          // printf(" ");
        }
        px += 1;
      }
    }
    py += 1;
    px = PX;
  }
}

let H            = 2.0_f32;
let REST_DENSITY = 1.0_f32;
let GRAVITY      = 0.05_f32;
let STIFFNESS    = 1.75_f32;
let RESTITUTION  = 0.05_f32;
let PARTICLES    = 48_u64;

type Sim = (
  particles:          [PARTICLES * PARTICLES]Particle,
  boundary_particles: [2 * 128 + 2 * 128 + 2 * 2][2]Real32,
  world_size:         [2]Real32
);

type Particle = (
  initial_position: [2]Real32,
  position:         [2]Real32,
  velocity:         [2]Real32,
  density:          Real32
);

fn sph_kernel(r: Real32) -> Real32 {
  let result = 0.45472841_f32; // 40 / (7 * pi * h^2)
  let q = r / H;
  if q <= 0.5 {
    result = result * (6.0 * (q*q*q - q*q) + 1.0);
  } else {
    let a = 1.0 - q;
    result = result * 2.0 * a*a*a;
  }
  return result;
}

fn particle_pressure(p: *Particle) -> Real32 {
  let pressure = STIFFNESS * (p.density - REST_DENSITY) >? 0.0;
  return pressure;
}

fn (sim: *Sim) init() {
  let world_size = new [2]Real32 { 128.0, 128.0 };
  sim.world_size = world_size;

  let particles = &sim.particles[0];
  let boundary_particles = &sim.boundary_particles[0];

  for let i = 0_s64; i < 128 + 2; i += 1 {
    boundary_particles[i]           = new [2]Real32 {(i as Real32) - 0.5, -0.5};
    boundary_particles[i + 128 + 2] = new [2]Real32 {(i as Real32) - 0.5, world_size[1] + 0.5};
  }
  for let i = 0_s64; i < 128; i += 1 {
    boundary_particles[i + 2 * (128 + 2)]       = new [2]Real32 {-0.5,                (i as Real32) + 0.5};
    boundary_particles[i + 2 * (128 + 2) + 128] = new [2]Real32 {world_size[0] + 0.5, (i as Real32) + 0.5};
  }

  let block_x = 0.5_f32;
  let block_y = 0.75 * world_size[1] - 0.5;

  for let y = 0_u64; y < PARTICLES; y += 1 {
    for let x = 0_u64; x < PARTICLES; x += 1 {
      let particle = &particles[y * PARTICLES + x];
      particle.position[0] = block_x + (x as Real32);
      particle.position[1] = block_y - (y as Real32);
    }
  }
}

fn (sim: *Sim) step() {
  let particles = &sim.particles[0];
  let boundary_particles = &sim.boundary_particles[0];

  // Apply forces and "advect" the particles.
  for let i = 0_u64; i < count of sim.particles; i += 1 {
    let particle = &particles[i];
    particle.initial_position = particle.position;
    particle.velocity[1] += GRAVITY;
    particle.position += particle.velocity;
  }

  // Estimate density.
  for let i = 0_u64; i < count of sim.particles; i += 1 {
    let particle = &particles[i];
    particle.density = 0.0;

    // Count fluid particles.
    for let j = 0_u64; j < count of sim.particles; j += 1 {
      let neighbor = &particles[j];
      let delta = particle.position - neighbor.position;
      let r = sqrt(delta[0] * delta[0] + delta[1] * delta[1]);
      if r < H {
        particle.density += sph_kernel(r);
      }
    }

    // Count boundary particles.
    for let j = 0_u64; j < count of sim.boundary_particles; j += 1 {
      let delta = particle.position - boundary_particles[j];
      let r = sqrt(delta[0] * delta[0] + delta[1] * delta[1]);
      if r < H {
        particle.density += sph_kernel(r);
      }
    }
  }

  // Compute pressure.
  for let i = 0_u64; i < count of sim.particles; i += 1 {
    let particle = &particles[i];

    let f_p = particle_pressure(particle) / (particle.density * particle.density);
    let force = new [2]Real32 { };

    for let j = 0_u64; j < count of sim.particles; j += 1 {
      if i == j {
        continue;
      }
      let neighbor = &particles[j];
      let d = particle.position - neighbor.position;
      let r = sqrt(d[0]*d[0] + d[1]*d[1]);
      if r >= H {
        continue;
      }
      if r <= 0.01 {
        if j < i {
          d[0] = 1.0;
        } else {
          d[0] = -1.0;
        }
        d[1] = 0.0;
        r = 1.0;
      } else {
        d /= new [2]Real32 { r, r };
      }
      let w = H - r;
      w *= 0.23873241_f32; // 12 / (pi * h^4)
      let f_n = particle_pressure(neighbor) / (neighbor.density * neighbor.density);
      let f = (f_p + f_n) * w;
      force += new [2]Real32 { f, f } * d;
    }

    for let j = 0_u64; j < count of sim.boundary_particles; j += 1 {
      let d = particle.position - boundary_particles[j];
      let r = sqrt(d[0]*d[0] + d[1]*d[1]);
      if r >= H {
        continue;
      }
      let w = H - r;
      w *= 0.23873241; // 12 / (pi * h^4)
      let f_n = particle_pressure(particle) / (REST_DENSITY * REST_DENSITY);
      let f = (f_p + f_n) * w;
      force += new [2]Real32 { f, f } * d;
    }

    particle.velocity += force / new [2]Real32 { particle.density, particle.density };
  }

  // Use pressure-corrected velocity and apply boundary conditions.
  for let i = 0_u64; i < count of sim.particles; i += 1 {
    let particle = &particles[i];
    particle.position = particle.initial_position + particle.velocity;

    for let c = 0_u64; c < 2; c += 1 {
      if particle.position[c] < 0.5 {
        particle.position[c] = 0.5;
        if particle.velocity[c] < 0.0 {
          particle.velocity[c] *= -RESTITUTION;
        }
      } else if particle.position[c] > sim.world_size[c] - 0.5 {
        particle.position[c] = sim.world_size[c] - 0.5;
        if particle.velocity[c] > 0.0 {
          particle.velocity[c] = particle.velocity[c] * -RESTITUTION;
        }
      }
    }
  }
}

fn (sim: *Sim) render(fb: *LimineFramebuffer) {
  let particles = &sim.particles[0];
  let boundary_particles = &sim.boundary_particles[0];

  // Draw the particles.
  for let i = 0_u64; i < count of sim.particles; i += 1 {
    let pressure = particle_pressure(&particles[i]) / STIFFNESS <? 1.0;
    let color = (0_u32, 255_u32, ((1.0 - pressure) * 255.0) as Uint32);
    draw_scaled_particle(fb, particles[i].position, make_color(fb, ...color));
  }

  for let i = 0_u64; i < count of sim.boundary_particles; i += 1 {
    let x = (boundary_particles[i][0] + 0.5) as Sint64;
    let y = (boundary_particles[i][1] + 0.5) as Sint64;
    draw_scaled_pixel(fb, x, y, make_color(fb, 0, 0, 0));
  }
}

fn draw_scaled_pixel(fb: *LimineFramebuffer, x: Sint64, y: Sint64, color: Uint32) {
  x *= 4;
  y *= 4;
  x += (fb.dimensions.0 as Sint64 - 4 * 128) / 2;
  y += (fb.dimensions.1 as Sint64 - 4 * 128) / 2;
  for let p = 0_s64; p < 16; p += 1 {
    let py = p & 3;
    let px = p >> 2;
    fb.address[(y + py - 3) * (fb.dimensions.0 as Sint64) + (x + px - 3)] = color;
  }
}

fn draw_scaled_particle(fb: *LimineFramebuffer, p: [2]Real32, color: Uint32) {
  let x = (4.0 * p[0] + 0.5) as Sint64;
  let y = (4.0 * p[1] + 0.5) as Sint64;
  x += (fb.dimensions.0 as Sint64 - 4 * 128) / 2;
  y += (fb.dimensions.1 as Sint64 - 4 * 128) / 2;
  fb.address[y * (fb.dimensions.0 as Sint64) + x] = color;
}